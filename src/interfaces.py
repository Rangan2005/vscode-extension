from abc import ABC, abstractmethod
from pathlib import Path
from typing import List, Dict, Any, Optional
from pydantic import BaseModel, Field
import uuid

# --- Pydantic Data Models (Shared Contracts) --- 
 
class FileNode(BaseModel): 
    """Represents a source code file node.""" 
    id: str = Field(..., description="Unique ID for the file node.") 
    filePath: str = Field(..., description="Absolute path to the file.") 
    language: str = Field(..., description="Identified language (e.g., 'python').") 
 
class FunctionNode(BaseModel): 
    """Represents a function definition node.""" 
    id: str = Field(..., description="Unique ID for the function node.") 
    name: str = Field(..., description="Name of the function.") 
    fileId: str = Field(..., description="ID of the file this function belongs to.") 
    startLine: int = Field(..., description="Starting line number (0-indexed).") 
    endLine: int = Field(..., description="Ending line number (0-indexed).") 
    # Add other relevant properties like 'signature', 'docstringSummary' later 
 
class ClassNode(BaseModel): 
    """Represents a class definition node.""" 
    id: str = Field(..., description="Unique ID for the class node.") 
    name: str = Field(..., description="Name of the class.") 
    fileId: str = Field(..., description="ID of the file this class belongs to.") 
    startLine: int = Field(..., description="Starting line number (0-indexed).") 
    endLine: int = Field(..., description="Ending line number (0-indexed).") 
    # Add other relevant properties like 'bases', 'methods' later 
 
class ParsedCodeModel(BaseModel): 
    """Represents the structured data extracted from a single source code file.""" 
    file: FileNode 
    functions: List[FunctionNode] = []
    classes: List[ClassNode] = [] 
    # Add other types of nodes like 'variables', 'imports' as needed later 
 
class GraphNodeData(BaseModel): 
    """Generic representation of a node in the graph database.""" 
    id: str = Field(..., description="Unique ID of the graph node (Gremlin 'id').") 
    type: str = Field(..., description="Type/label of the node (e.g., 'File', 'Function', 'Class').") 
    name: str = Field(..., description="Primary name property of the node.") 
    filePath: Optional[str] = Field(None, description="File path if applicable.") 
    startLine: Optional[int] = Field(None, description="Start line if applicable.") 
    properties: Dict[str, Any] = Field({}, description="Additional properties of the node.") 
 
class GraphEdgeData(BaseModel): 
    """Generic representation of an edge in the graph database.""" 
    id: str = Field(..., description="Unique ID of the graph edge (Gremlin 'id').") 
    sourceId: str = Field(..., description="ID of the source node.") 
    targetId: str = Field(..., description="ID of the target node.") 
    type: str = Field(..., description="Type/label of the edge (e.g., 'CONTAINS', 'CALLS').") 
    properties: Dict[str, Any] = Field({}, description="Additional properties of the edge.") 
 
# Models for LLM communication 
class LLMContext(BaseModel): 
    """Represents the context extracted from the graph for LLM input.""" 
    entityId: str = Field(..., description="ID of the primary entity for which context is gathered.") 
    codeSnippet: str = Field(..., description="Relevant code snippet.") 
    dependencies: List[str] = Field([], description="Names/IDs of directly related dependencies.") 
    relatedEntities: List[str] = Field([], description="Names/IDs of other relevant entities (e.g.,calling functions, related classes).") 
 
class LLMPrompt(BaseModel): 
    """Represents a structured prompt for the LLM.""" 
    instruction: str = Field(..., description="The main instruction for the LLM (e.g., 'generate documentation').") 
    context: LLMContext = Field(..., description="Structured code context for the LLM.") 
    # Add other parameters like 'outputFormat', 'temperature' later 
 
class LLMResponse(BaseModel): 
    """Represents the structured response from the LLM.""" 
    generatedText: str = Field(..., description="The text generated by the LLM.") 
    # Add other metadata like 'tokenUsage', 'modelId' later 
 
# --- Service Interfaces (Connector Definitions - ABCs) ---
class ICodeParserService(ABC): 
    """ 
    Interface for services responsible for language identification and code parsing. 
    Implemented by Developer 1. Used by Developer 2 and LSP Server Manager. 
    """ 
    @abstractmethod 
    def identifyLanguage(self, filePath: Path) -> str: 
        """ 
        Identifies the programming language of a file based on its extension. 
        Returns a lowercase string (e.g., 'python', 'javascript', 'unknown'). 
        """ 
        pass 
 
    @abstractmethod 
    def parseCode(self, filePath: Path, codeContent: str) -> ParsedCodeModel: 
        """ 
        Parses the given code content using Tree-sitter and extracts structured entities. 
        Returns a Pydantic model representing the parsed code. 
        """ 
        pass 
 
class IGraphQueryService(ABC): 
    """ 
    Interface for services that build and query the code graph. 
    Implemented by Developer 2. Used by Developer 3 and LSP Server Manager. 
    """ 
    @abstractmethod 
    def ingestParsedCode(self, parsedCode: ParsedCodeModel): 
        """ 
        Ingests parsed code data into the graph database, creating/updating nodes and edges. 
        This method consumes the output of ICodeParserService. 
        """ 
        pass 
 
    @abstractmethod 
    def getAllNodes(self, nodeType: Optional[str] = None) -> List[GraphNodeData]: 
        """ 
        Retrieves all graph nodes, optionally filtered by type. 
        """ 
        pass 
 
    @abstractmethod
    def getConnectedNodes(self, nodeId: str, edgeType: Optional[str] = None) -> List[GraphNodeData]: 
        """ 
        Retrieves nodes connected to a given node, optionally filtered by edge type. 
        """ 
        pass 
 
    @abstractmethod 
    def getCodeGraphSnapshot(self, filePath: str) -> Dict[str, Any]: 
        """ 
        Retrieves a simplified graph structure (nodes and edges) for a given file 
        or a specific subgraph, suitable for visualization. 
        Returns a dictionary like {'nodes': [...], 'edges': [...]}. 
        """ 
        pass 
 
class ILLMService(ABC): 
    """ 
    Interface for services that interact with the local LLM. 
    Implemented by Developer 3. Used by LSP Server Manager. 
    """ 
    @abstractmethod 
    def __init__(self, modelPath: Path, graphQueryService: IGraphQueryService): 
        """Initializes the LLM service with a model path and a graph query service.""" 
        pass 
 
    @abstractmethod 
    def getContextForEntity(self, entityId: str) -> LLMContext: 
        """ 
        Retrieves and structures relevant code context for an entity from the graph, 
        suitable for feeding to an LLM. 
        """ 
        pass 
 
    @abstractmethod 
    def generateText(self, prompt: LLMPrompt) -> LLMResponse: 
        """ 
        Generates text using the local LLM based on a structured prompt. 
        """ 
        pass